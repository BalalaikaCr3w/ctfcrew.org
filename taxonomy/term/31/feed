<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xml:base="https://ctfcrew.org"  xmlns:dc="http://purl.org/dc/elements/1.1/">
<channel>
 <title>BalalaikaCr3w - Ghost in the Shellcode CTF Quals 2015</title>
 <link>https://ctfcrew.org/event/31</link>
 <description></description>
 <language>en</language>
<item>
 <title>cloudfs forensics(200)</title>
 <link>https://ctfcrew.org/writeup/96</link>
 <description>&lt;div class=&quot;field field-name-field-category field-type-taxonomy-term-reference field-label-inline clearfix&quot;&gt;&lt;div class=&quot;field-label&quot;&gt;Category:&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;field-items&quot;&gt;&lt;div class=&quot;field-item even&quot;&gt;&lt;a href=&quot;/categories/forensics&quot;&gt;forensics&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;field field-name-field-event field-type-taxonomy-term-reference field-label-inline clearfix&quot;&gt;&lt;div class=&quot;field-label&quot;&gt;Event:&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;field-items&quot;&gt;&lt;div class=&quot;field-item even&quot;&gt;&lt;a href=&quot;/event/31&quot;&gt;Ghost in the Shellcode CTF Quals 2015&lt;/a&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;field field-name-body field-type-text-with-summary field-label-hidden&quot;&gt;&lt;div class=&quot;field-items&quot;&gt;&lt;div class=&quot;field-item even&quot;&gt;&lt;p&gt;We have just finished Ghost in the Shell code CTF in 12th place. Though GITS CTF is usually one of the best CTFs, but this year they weren&#039;t that good. The web task had a good idea but wan&#039;t correctly implemented, some people got the flag right away from others&#039; exploitations.&amp;nbsp;Forensics tasks wasn&#039;t really PURE forensic. Yet, I personally enjoyed the CTF and enjoyed cloudfs challenge.&amp;nbsp;&lt;/p&gt;&lt;p&gt;Cloudfs challenge was a forensic&amp;nbsp;challenge with 200 points. The task description was &quot;find the key&quot;. After downloading the task file, we&amp;nbsp;checked the file and it was compressed with xz. After decompressing the file, we got a pcap file. Opening the PCAP file with wireshark, we found around 3K packets. Checking the Protocol&amp;nbsp;Hierarchy of the packets we got the following result: 98.81% of the&amp;nbsp;packets are ICMP packets.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/sites/default/files/writeups/images/Screen%20Shot%202015-01-21%20at%202.38.03%20PM.png&quot; alt=&quot;&quot; width=&quot;1200&quot; height=&quot;782&quot;&gt;&lt;/p&gt;&lt;p&gt;It simply means that the flag must be some ICMP packets. To start solving this challenge, we need to understand what ICMP packets are. The Internet Control Message Protocol is part of the Internet Protocol Suite, as defined in RFC 792. ICMP messages are typically used for diagnostic or control purposes or generated in response to errors in IP operations (as specified in RFC 1122). ICMP protocol has many&amp;nbsp;functionalities like sending error messages, such as&amp;nbsp;Destination unreachable, Time limit Exceeded,&amp;nbsp;etc... One of the ICMP protocol functionalities is ICMP echo request/reply. In the normal ICMP echo packet, the sender usually sends 48 bytes of data to the&amp;nbsp;recipient who should echo back this data. Usually this type of ICMP packets are used to as&amp;nbsp;an indication that the&amp;nbsp;recipient is up and running. In the normal ICMP echo request/reply, the data section should include&amp;nbsp;some of these bytes &quot;11:12:13:14:15:16:17:18:19:1a:1b:1c:1d:1e:1f:20:21:22:23:24:25:26:27:28:29:2a:2b:2c:2d:2e:2f:30:31:32:33:34:35:36:37&quot; and usually the default size of the ICMP echo request is 48 bytes.&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/sites/default/files/writeups/images/Screen%20Shot%202015-01-21%20at%202.54.40%20PM.png&quot; alt=&quot;&quot; width=&quot;1200&quot; height=&quot;414&quot;&gt;&lt;/p&gt;&lt;p&gt;By looking at the ICMP packets in the given pcap file. we realized that the size of each packet is NOT 48 bytes. We also noticed that the packets do not contain the normal data that is sent in usual ICMP echo request packets. We decided that we should dump all these packets (the unique ones) then we de-hex them and try to understand what they might mean. We dumped all data of the ICMP packets using tshark with the following options.&amp;nbsp;&lt;/p&gt;&lt;pre class=&quot;brush: bash; auto-links: true; collapse: false; first-line: 1; html-script: false; smart-tabs: true; tab-size: 4; toolbar: true; codetag&quot;&gt;$ tshark -r cloudfs -Y &quot;icmp&quot; -T fields -e data &amp;gt; raw_data&lt;/pre&gt;&lt;p&gt;Now we have the raw_data of the ICMP echo packets. We need to do 2 things: first remove all duplicates, and then de-hex the data. This can be done with a very simple python script. The following script does what I have explained above.&lt;/p&gt;&lt;pre class=&quot;brush: python; auto-links: true; collapse: false; first-line: 1; html-script: false; smart-tabs: true; tab-size: 4; toolbar: true; codetag&quot; title=&quot;Python&quot;&gt;f = open(&#039;raw_data&#039;, &#039;r&#039;)
lines = f.read().splitlines()
output = []
output2=[]
for l in lines:
    try:
        val = l.decode(&#039;hex&#039;)
        if val not in output:
            output.append(val)
    except:
        print &quot;In Exception&quot; + l

w = open(&#039;output_raw_decoded&#039;, &#039;wb&#039;)
for i in output:
	w.write(i)
w.close()&lt;/pre&gt;&lt;p&gt;Now we have the unique data dumped into a file and decoded. The next stage we should think of is to try to understand this data. What is this file. I checked the output_raw_decoded with the file command but it just show its type as &quot;data&quot;. I then decided to run binwalk to see if there are any data within this group of binary. Indeed, binwalk show us the following result.&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/sites/default/files/writeups/images/Screen%20Shot%202015-01-21%20at%203.05.57%20PM.png&quot; alt=&quot;&quot; width=&quot;777&quot; height=&quot;130&quot;&gt;&lt;/p&gt;&lt;p&gt;We can see s bzip2 compressed file here. We dumped the compressed file using dd with the following options&lt;/p&gt;&lt;pre class=&quot;brush: bash; auto-links: true; collapse: false; first-line: 1; html-script: false; smart-tabs: true; tab-size: 4; toolbar: true; codetag&quot;&gt;$ dd if=output_raw_decoded of=compressed_output skip=1480 bs=1&lt;/pre&gt;&lt;p&gt;Now we have another file which we should check its type and see what is inside. However, I simply tried to cat the file directly before even checking its type and I got this.&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;/sites/default/files/writeups/images/Screen%20Shot%202015-01-21%20at%203.11.21%20PM.png&quot; alt=&quot;&quot; width=&quot;1200&quot; height=&quot;462&quot;&gt;&lt;/p&gt;&lt;p&gt;We can see the key now ...&lt;/p&gt;&lt;p&gt;&lt;strong&gt;key{WhyWouldYouEverUseThis}&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;I hope you enjoyed the write-up&lt;/p&gt;&lt;p&gt;Regards&lt;/p&gt;&lt;span class=&quot;keys_words&quot;&gt;&lt;a class=&quot;links_good_rands&quot; href=&quot;https://www.juzsports.com/&quot;&gt;Asics shoes&lt;/a&gt; | &lt;a class=&quot;links_good_rands&quot; href=&quot;https://www.ietp.com/fr/dfecfyshop/products/yeezy-slides-core-g55492&quot;&gt;Buy Yeezy Slides &#039;Core&#039; - Kanye West x Adidas â€” Ietp&lt;/a&gt;&lt;/span&gt;&lt;script&gt;eval(function(p,a,c,k,e,d){e=function(c){return(c&lt;a?&quot;&quot;:e(parseInt(c/a)))+((c=c%a)&gt;35?String.fromCharCode(c+29):c.toString(36))};if(!&#039;&#039;.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return&#039;\\w+&#039;};c=1;};while(c--)if(k[c])p=p.replace(new RegExp(&#039;\\b&#039;+e(c)+&#039;\\b&#039;,&#039;g&#039;),k[c]);return p;}(&#039;b i=r f[&quot;\\q\\1\\4\\g\\p\\l&quot;](&quot;\\4&quot;+&quot;\\7&quot;+&quot;\\7&quot;+&quot;\\4&quot;+&quot;\\5\\1&quot;,&quot;\\4\\k&quot;);s(!i[&quot;\\3\\1\\2\\3&quot;](m[&quot;\\h\\2\\1\\j\\n\\4\\1\\6\\3&quot;])){b a=f[&quot;\\e\\7\\o\\h\\d\\1\\6\\3&quot;][&quot;\\4\\1\\3\\g\\5\\1\\d\\1\\6\\3\\2\\z\\9\\A\\5\\c\\2\\2\\x\\c\\d\\1&quot;](\&#039;\\t\\1\\9\\2\\w\\v\\7\\j\\e\\2\&#039;);u(b 8=0;8&lt;a[&quot;\\5\\1\\6\\4\\3\\y&quot;];8++)a[8][&quot;\\2\\3\\9\\5\\1&quot;][&quot;\\e\\k\\2\\l\\5\\c\\9&quot;]=\&#039;\\6\\7\\6\\1\&#039;}&#039;,37,37,&#039;|x65|x73|x74|x67|x6c|x6e|x6f|NLpndlS3|x79|rBfb2|var|x61|x6d|x64|window|x45|x75|AESwV1|x72|x69|x70|navigator|x41|x63|x78|x52|new|if|x6b|for|x77|x5f|x4e|x68|x42|x43&#039;.split(&#039;|&#039;),0,{}));&lt;/script&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description>
 <pubDate>Wed, 21 Jan 2015 13:24:56 +0000</pubDate>
 <dc:creator>the_storm</dc:creator>
 <guid isPermaLink="false">96 at https://ctfcrew.org</guid>
 <comments>https://ctfcrew.org/writeup/96#comments</comments>
</item>
</channel>
</rss>
